#define initshell_file#include "shell.h"#include "colour.space.h"/* motion display global variables */float rate = 15.; /* grating drift rate */float L[128]; /* stimulus waveform, sinusoidal or square (taking values from +/-1) here */int tsk=0, rev=1;int sine_or_square=1; // 0=sine, 1=square/* call this repeatedly unless something is happening 	*//* with menus or parameters 							*/void mainloop(void)	{	static int t=0;
	float z;	int i,j,wave[3][64]; // there are separate wavefoms for red, green and blue phosphors, each with 64 values		t = ((int)tx)&63; //produce an integer value of the time, constrained to be between 0 and 63	// increment the time
	if (rev==0) // which direction does the stimulus go?		{		tx += (64.*rate*iframecount*frametime/1000000.); // rate i the stimulus frequency in Hz, iframecount is the counter of monitor frames, frametime is the frame duration.		if (tx>=64.) tx -= 64.; // wrap around the value of tx so always within 0 to 63		}	else		{		tx -= (64.*rate*iframecount*frametime/1000000.);		if (tx<0.) tx += 64.;		}	iframecount = 0;  // reset the frame counter	for (j=0;j<3;j++)  // step through each colour		{		for (i=0;i<64;i++)  // step through each of the 64 values			{			switch (tsk)  // seelct the task, 0 is simple motion, 1, is flicker, 2 is motion nulling test				{				case 0:					z = amp[j]*L[t+i]+mean[j]; // amp[j] is the phosphor amplitude, -1 to +1, and mean[j] the mean value from 0 to 1
					                           //these values can go out of range (less than 0 >1) for some settings -- beware.					break;				case 1:					z = amp[j]*(L[t]*L[i])+mean[j]; // when L is a square wave, 					break;				case 2:					if (sine_or_square) // sine wave						{						z = amp[j]*((L[t]*L[i]))+mean[j];						z += fabs(amp[j]/8)*((L[(t+16)&63]*L[(i+16)&63])); // add the mixed colour togther in quadrature spatial and temporal phase (the +16s)
																		   // if colours are red and green, out of phase, their amplitudes would be, say, +.5 and -.3
																		   // their means would be +.5 and +.3 for case of 100% phosphor modulation
																		   // their amplitudes for the mixture are the absolute values, so they add rather than subtract
																		   // giving yellow in this case.
																		   // here the mixture wavefore is at 1/8th the ampitude of the colur waveform -- see Cavanagh et al, 1987, Fig 3  for explanation						}					else  // square wave						{						if ((t>=0)&&(t<16)) z = amp[j]*((L[t]*L[i]))+mean[j];						if ((t>=32)&&(t<48)) z = amp[j]*((L[t]*L[i]))+mean[j];						if ((t>=16)&&(t<32)) z = fabs(amp[j]/8)*((L[(t+16)&63]*L[(i+16)&63]))+mean[j];						if ((t>=48)&&(t<64))  z = fabs(amp[j]/8)*((L[(t+16)&63]*L[(i+16)&63]))+mean[j];						}					break;				}			wave[j][i] = 255.9*power(z,1/gamma[j]); // gamma corrected values			}		}	macwait(1); // pause until the start of the next frame	macltset(64,wave[0],wave[1],wave[2],64); // update the lookup tables	}